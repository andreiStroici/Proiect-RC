###### [<< Înapoi la cuprins](../Cuprins.md)
###### [< Clasa DISCONNECT](20.%20DISCONNECT.md)
# Implementare Socket
### Berkley Sockets, o inovație fundamentală în domeniul rețelisticii, a jucat un rol esențial în evoluția comunicațiilor între calculatoare.
### Acest mecanism de comunicație va fi folosit pentru comunicarea dintre client și broker. Această comunicare se realizează în 2 sensuri: de la client la broker și respecitv, de la broker la client. Întrucât trimiterea și primirea mesajelor se produce în thread-uri diferite vom avea:
1. Trimiterea de mesaje  
Acest proces se realizează după ce conținutul unui pachet este transformat în șir de caractere. Următoare secvență de instrucțiuni vor fi elementele de la care vom pleca pentru a realiza trimiterea pachetelor folosid Socket-uri și protocolul TCP:
```Python
import socket

# Creare obiect soket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Conectare la server folodind adresa IP si portul
s.connect(('server_ip_address', port_number))

# mqtt_packet contine datele sub forma uniui string
s.send(mqtt_packet.encode())  # codificare string in octeti
```
2. Recepția mesajelor  
Pentru recepția mesajelor vom folosi Socket Pool. Am ales această metodă pentru că nu este cunoscut momentul la care clientul primește un pachet nou. Astfel programul este blocat până la apariția unui pachet. De asemenea, alegerea să se creeze un thread separat pentru primirea pachetelor, facilitează această abordare. Astfel, deși thread-ul în care se așteaptă primirea pachetelor, este blocat (cât timp așteaptă un nou pachet), restul aplicației nu va fi afectată. De asemenea, comunicarea dintre thread-uri se va realiza prin pipe-uri. De la thread-ul de client vom primi numai un mesaj care va termina procesul curent. Următoarele linii de cod reprezintă punctul de plecare pentru acest mecanism:
```Python
import socket
import select
import os

# Creare socket
s_conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s_conn.connect(('server_ip_address', port_number))

# Creare pipe
recv_pipe, send_pipe = os.pipe()

# Inițializare obiect poll și înregistrare socket și pipe
poll_obj = select.poll()
poll_obj.register(s_conn, select.POLLIN)
poll_obj.register(recv_pipe, select.POLLIN)

while True:
    events = poll_obj.poll(1024)  # Se așteaptă evenimente

    for fd, event in events:
        if fd == s_conn.fileno():  # Evenimente de la socket
           # procesare pachet
        elif fd == recv_pipe:  # Evenimente de la pipe
            # terminare thread
```
###### [Interfata cu utilizatorul >](22.%20Interfața%20cu%20utilizatorul.md)
